// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.13;

import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * @title AffiliateMarketing
 * @author Riley Stephens
 * @dev Provides the ability to manage a affiliates and attibute actions taken
 * to them. Each affilate agreement can be customized to allow for different actions
 * and rewards. Affiliates can be associated with an abitrary number of agreements.
 *
 * New Design
 * Rewards will be a % of total "sales" rather than a fixed amount per action.
 * Anyone can become an affiliate of the campaign for a fixed 2% of their sales.
 * A priveleged account can add affiliates to the campaign with a custom % agreement.
 */
contract AffiliateMarketing {
    using SafeERC20 for IERC20;
    using Counters for Counters.Counter;

    /**
     * @dev Represents a real world affiliate marketing campaign that tracks affiliates,
     * actions taken, payouts, and allows for timed campaigns and/or budget caps.
     * @param uri URI containing the campaign's information
     * @param owner The owner of the campaign
     * @param startTime The time when the campaign becomes active
     * @param endTime The time the campaign becomes inactive
     * @param standardRewardPercentage Standard percentage of sales that will be paid to the affiliates
     * @param totalAffiliates Number of affiliates participating in the campaign
     * @param totalActionsTaken Number of actions taken by other accounts that have been attributed to affiliates
     * @param totalSales The amount of sales (in wei) generated by affiliates
     * @param affiliates Mapping of addresses to affiliate info pertaining to the campaign
     */
    struct Campaign {
        string uri;
        address owner;
        uint128 startTime;
        uint128 endTime;
        uint128 standardRewardPercentage;
        uint64 totalAffiliates;
        uint64 totalSalesCount;
        uint256 totalSalesValue;
        mapping(address => Affiliate) affiliates;
    }

    /**
     * @dev An Affiliate represents an account's participation in an affiliate marketing campaign.
     * Each affiliate can receive a standard or custom percentage of sales based on the implmented
     * user registration logic. An affiliate tracks the actions/sales they are responsible for and
     * the rewards they have withdrawn.
     * @param isRegistered Whether the affiliate is registered with the campaign
     * @param amountWithdrawn The amount (in wei) of rewards the affilate has withdrawn
     * @param salesValue The amount (in wei) of sales generated by the affiliate
     * @param salesCount Number of sale made that were attributed to the affiliate
     * @param customRewardPercentage (Optional - 0 if none) Custom percentage of sales that will be paid to the affiliate
     */
    struct Affiliate {
        bool isRegistered;
        uint256 amountWithdrawn;
        uint256 salesValue;
        uint128 salesCount;
        uint128 customRewardPercentage;
    }

    Counters.Counter private _campaignIdCounter;

    mapping(address => Affiliate) private _affiliates;
    mapping(uint256 => Campaign) private _campaigns;

    uint256 immutable percentCeiling = 10000; // Allows for percentages with 2 decimal places. Ex: 10.55% = 1055

    /***********************************|
    |          View Functions           |
    |__________________________________*/

    /**
     * @dev Gets affiliate's reward owed for a specified campaign
     * @param _campaignId The ID of the campaign to query
     * @param _affiliate The affiliate address to query
     * @return The affiliate's reward (in wei) for the specified campaign
     */
    function getAffiliateRewardTotal(uint256 _campaignId, address _affiliate)
        public
        view
        returns (uint256)
    {
        return _caclulateAffiliateRewardTotal(_campaignId, _affiliate);
    }

    /**
     * @dev Gets affiliate's reward owed for a specified campaign
     * @param _campaignId The ID of the campaign to query
     * @param _affiliate The affiliate address to query
     * @return The affiliate's reward (in wei) for the specified campaign
     */
    function getAffiliateRewardEntitlement(
        uint256 _campaignId,
        address _affiliate
    ) public view returns (uint256) {
        return _caclulateAffiliateRewardEntitlement(_campaignId, _affiliate);
    }

    /***********************************|
    |         Helper Functions          |
    |__________________________________*/

    /**
     * @dev Returns whether the campaign exists
     * @param _campaignId ID of the campaign to query
     * @return True if campaign owner is not zero address, False if so
     */
    function _campaignExists(uint256 _campaignId)
        internal
        view
        virtual
        returns (bool)
    {
        return _campaigns[_campaignId].owner != address(0);
    }

    /**
     * @dev Returns whether the campaign is currently active
     * @param _campaignId ID of the campaign to query
     * @return True if campaign is active, False otherwise
     */
    function _campaignIsActive(uint256 _campaignId)
        internal
        view
        virtual
        returns (bool)
    {
        Campaign storage campaign = _campaigns[_campaignId];
        return
            campaign.startTime < block.timestamp &&
            campaign.endTime > block.timestamp;
    }

    /**
     * @dev Calculate affiliate's total rewards for a specified campaign
     * @param _campaignId The ID of the campaign to query
     * @param _affiliate The affiliate address to query
     * @return Total value of sales driven by the affiliate * affiliate's reward percentage
     */
    function _caclulateAffiliateRewardTotal(
        uint256 _campaignId,
        address _affiliate
    ) internal view virtual returns (uint256) {
        Campaign storage campaign = _campaigns[_campaignId];
        Affiliate storage affiliate = campaign.affiliates[_affiliate];

        if (affiliate.customRewardPercentage == 0) {
            // Affiliate has standard campaign reward percentage
            return
                (campaign.totalSalesValue * campaign.standardRewardPercentage) /
                percentCeiling;
        }

        // Affiliate has custom reward percentage
        return
            (campaign.totalSalesValue * affiliate.customRewardPercentage) /
            percentCeiling;
    }

    /**
     * @dev Calculate the reward currently entitled to an affiliate for a specified campaign
     * @param _campaignId The ID of the campaign to query
     * @param _affiliate The affiliate address to query
     * @return Total affiliate reward - amount of rewards already withdrawn
     */
    function _caclulateAffiliateRewardEntitlement(
        uint256 _campaignId,
        address _affiliate
    ) internal view virtual returns (uint256) {
        uint256 totalRewards = _caclulateAffiliateRewardTotal(
            _campaignId,
            _affiliate
        );

        Campaign storage campaign = _campaigns[_campaignId];
        Affiliate storage affiliate = campaign.affiliates[_affiliate];

        return totalRewards - affiliate.amountWithdrawn;
    }

    /***********************************|
    |  Campaign Management Functions    |
    |__________________________________*/

    /**
     * @dev Create a new campaign from the given parameters.
     *
     * Requirements:
     * - `_owner` cannot be the zero address
     * - `_startTime` must be in the future
     * - `_endTime` must be greater than `_startTime`
     * - `_rewardPercentage` must be between 0 and 10000
     *
     * @param _owner Owner of the campaign
     * @param _uri URI containing the new campaign's information
     * @param _startTime The time when the campaign becomes active
     * @param _endTime The time the campaign becomes inactive
     * @param _rewardPercentage Percentage of sales generated by affiliates that will be paid to the affiliate
     */
    function _createCampaign(
        address _owner,
        string memory _uri,
        uint128 _startTime,
        uint128 _endTime,
        uint128 _rewardPercentage
    ) internal virtual {
        require(
            _owner != address(0),
            "AffiliateMarketing: Owner cannot be the 0x0"
        );
        require(
            _startTime > block.timestamp - 1,
            "AffiliateMarketing: Start time cannot be in the past"
        );
        require(
            _startTime < _endTime,
            "AffiliateMarketing: Start time must be before end time"
        );

        require(_rewardPercentage > 0, "AffiliateMarketing: Reward is 0");
        require(
            _rewardPercentage < percentCeiling,
            "AffiliateMarketing: Exceeded reward ceiling"
        );

        // Get the current campaign ID and increment
        uint256 campaignId = _campaignIdCounter.current();
        _campaignIdCounter.increment();

        Campaign storage newCampaign = _campaigns[campaignId];
        newCampaign.owner = _owner;
        newCampaign.uri = _uri;
        newCampaign.startTime = _startTime;
        newCampaign.endTime = _endTime;
        newCampaign.standardRewardPercentage = _rewardPercentage;
    }

    /**
     * @dev Update the URI of an existing campaign.
     *
     * Requirements:
     * - `_campaignId` must exist.
     * - `_owner` must match `_campaignId` owner.
     * - `_uri` cannot be blank.
     *
     * @param _campaignId ID of the campaign to update
     * @param _owner Owner of the campaign
     * @param _uri New URI for the campaign
     */
    function _updateCampaignMetadata(
        uint256 _campaignId,
        address _owner,
        string memory _uri
    ) internal virtual {
        require(
            _campaignExists(_campaignId),
            "AffiliateMarketing: Campaign does not exist"
        );
        require(
            bytes(_uri).length > 0,
            "AffiliateMarketing: URI cannot be empty"
        );

        Campaign storage campaign = _campaigns[_campaignId];
        require(
            campaign.owner == _owner,
            "AffiliateMarketing: Not campaign owner"
        );

        campaign.uri = _uri;
    }

    /**
     * @dev Update the owner address of an existing campaign.
     *
     * Requirements:
     * - `_campaignId` must exist.
     * - `_owner` must match `_campaignId` owner.
     * - `_newOwner` cannot be the zero address.
     *
     * @param _campaignId ID of the campaign to update
     * @param _owner Owner of the campaign
     * @param _newOwner New owner address
     */
    function _updateCampaignOwner(
        uint256 _campaignId,
        address _owner,
        address _newOwner
    ) internal virtual {
        Campaign storage campaign = _campaigns[_campaignId];
        require(
            _campaignExists(_campaignId),
            "AffiliateMarketing: Campaign does not exist"
        );
        require(
            campaign.owner == _owner,
            "AffiliateMarketing: Not campaign owner"
        );
        require(
            _newOwner != address(0),
            "AffiliateMarketing: Owner cannot be 0x0"
        );
        campaign.owner = _newOwner;
    }

    /**
     * @dev Add affiliate that uses campaign's standard reward to campaign.
     *
     * Requirements:
     * - `_campaignId` must exist.
     * - `_affiliate` cannot be the zero address.
     * - `_affiliate` cannot already be an affiliate of the campaign.
     *
     * @param _campaignId The ID of the campaign to add affiliate to
     * @param _affiliate The affiliate address to add to campaign
     */
    function _addStandardAffiliate(uint256 _campaignId, address _affiliate)
        internal
        virtual
    {
        Campaign storage campaign = _campaigns[_campaignId];
        require(
            _campaignExists(_campaignId),
            "AffiliateMarketing: Campaign does not exist"
        );
        require(
            !campaign.affiliates[_affiliate].isRegistered,
            "AffiliateMarketing: Already joined campaign"
        );
        require(
            _affiliate != address(0),
            "AffiliateMarketing: Affiliate cannot be 0x0"
        );

        Affiliate storage affiliate = campaign.affiliates[_affiliate];
        affiliate.isRegistered = true;

        unchecked {
            campaign.totalAffiliates += 1;
        }
    }

    /**
     * @dev Add affiliate that uses custom reward to campaign
     *
     * Requirements:
     * - `_campaignId` must exist.
     * - `_affiliate` cannot be the zero address.
     * - `_affiliate` cannot already be an affiliate of the campaign.
     * - `_customRewardPercentage` must be between 0 and 10000
     *
     * @param _campaignId The ID of the campaign to add affiliate to
     * @param _affiliate The affiliate address to add to campaign
     * @param _customRewardPercentage Custom percentage of sales that will be paid to the affiliate
     */
    function _addCustomAffiliate(
        uint256 _campaignId,
        address _owner,
        address _affiliate,
        uint128 _customRewardPercentage
    ) internal virtual {
        Campaign storage campaign = _campaigns[_campaignId];
        Affiliate storage affiliate = campaign.affiliates[_affiliate];

        require(
            campaign.owner == _owner,
            "AffiliateMarketing: Not campaign owner"
        );

        require(_customRewardPercentage > 0, "AffiliateMarketing: Reward is 0");
        require(
            _customRewardPercentage <= percentCeiling,
            "AffiliateMarketing: Exceeded reward ceiling"
        );

        _addStandardAffiliate(_campaignId, _affiliate);
        affiliate.customRewardPercentage = _customRewardPercentage;
    }

    /**
     * @dev Credit affiliate with sale.
     *
     * Requirements:
     * - `_campaignId` must exist.
     * - `_affiliate` must be registered to the campaign.
     * - `_saleValue` must be greater than 0.
     *
     * @param _campaignId The ID of the campaign to add affiliate to
     * @param _affiliate The affiliate address to add to campaign
     * @param _saleValue The value of the sale (in wei)
     */
    function _attributeSaleToAffiliate(
        uint256 _campaignId,
        address _affiliate,
        uint256 _saleValue
    ) internal virtual {
        Campaign storage campaign = _campaigns[_campaignId];
        Affiliate storage affiliate = campaign.affiliates[_affiliate];

        require(
            _campaignExists(_campaignId),
            "AffiliateMarketing: Campaign does not exist"
        );
        require(
            affiliate.isRegistered,
            "AffiliateMarketing: Affiliate not registered"
        );
        require(_saleValue > 0, "AffiliateMarketing: Sale value is 0");

        campaign.totalSalesValue += _saleValue;
        affiliate.salesValue += _saleValue;

        unchecked {
            campaign.totalSalesCount += 1;
            affiliate.salesCount += 1;
        }
    }

    /**
     * @dev Send ETH reward to affiliate.
     *
     * Requirements:
     * - `_campaignId` must exist.
     * - `_affiliate` must be registered to the campaign.
     * - `_saleValue` must be greater than 0.
     *
     * @param _campaignId The ID of the campaign to query
     * @param _affiliate The affiliate address to send rewards to
     */
    function _sendAffiliateReward(uint256 _campaignId, address _affiliate)
        internal
        virtual
    {
        Campaign storage campaign = _campaigns[_campaignId];
        Affiliate storage affiliate = campaign.affiliates[_affiliate];

        require(
            _campaignExists(_campaignId),
            "AffiliateMarketing: Campaign does not exist"
        );
        require(
            affiliate.isRegistered,
            "AffiliateMarketing: Affiliate not registered"
        );

        uint256 reward = _caclulateAffiliateRewardEntitlement(
            _campaignId,
            _affiliate
        );

        require(reward > 0, "AffiliateMarketing: No reward");

        // Send the reward to the affiliate
        affiliate.amountWithdrawn += reward;
        payable(_affiliate).transfer(reward);
    }
}
