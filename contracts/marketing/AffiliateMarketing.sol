// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.13;

import "@openzeppelin/contracts/utils/Counters.sol";

/**
 * @title AffiliateMarketing
 * @author Riley Stephens
 * @dev Provides the ability to manage a affiliates and attibute actions taken
 * to them. Each affilate agreement allows for custom commission rates.
 */
contract AffiliateMarketing {
    using Counters for Counters.Counter;

    event CreateCampaign(
        uint256 indexed id,
        address indexed owner,
        uint128 startTime,
        uint128 endTime,
        uint32 commission,
        string uri
    );

    event UpdateCampaignMetadata(uint256 indexed id, string uri);

    event UpdateCampaignOwner(uint256 indexed id, address newOwner);

    event AddAffiliate(
        uint256 indexed campaignId,
        uint256 affiliateId,
        address affiliateAddress,
        uint32 commission
    );

    event AttributeSale(
        uint256 indexed campaignId,
        uint256 indexed affiliateId,
        uint256 saleValue
    );

    event SendRewards(uint256 indexed affiliateId, uint256 rewardValue);

    /**
     * @dev An Affiliate represents an account's participation in campaigns by tracking
     * the actions/sales they are responsible for and the rewards they have withdrawn.
     * Each affiliate can receive a standard or custom percentage of sales based on the implmented
     * user registration logic.
     * @param amountWithdrawn The amount (in wei) of rewards the affilate has withdrawn
     * @param salesValue The amount (in wei) of sales generated by the affiliate
     * @param salesCount Number of sale made that were attributed to the affiliate
     */
    struct Affiliate {
        address account;
        uint32 commission;
        uint32 salesCount;
        uint256 salesValue;
        uint256 amountWithdrawn;
    }

    /**
     * @dev Represents a real world affiliate marketing campaign that tracks affiliates,
     * actions taken, payouts, and allows for timed campaigns and/or budget caps.
     * @param totalSalesValue The amount of sales (in wei) generated by affiliates
     * @param totalSalesCount Number of sales that have been attributed to affiliates
     * @param totalAffiliates Number of affiliates participating in the campaign
     * @param standardCommission Standard percentage of sales that will be paid to the affiliates
     * @param startTime The time when the campaign becomes active
     * @param endTime The time the campaign becomes inactive
     * @param owner The owner of the campaign
     * @param uri (Optional) URI containing the campaign's information
     */
    struct Campaign {
        address owner;
        uint32 standardCommission;
        uint32 totalAffiliates;
        uint32 totalSalesCount;
        uint256 totalSalesValue;
        uint128 startTime;
        uint128 endTime;
        string uri;
    }

    // Allows for percentages with 2 decimal places. Ex: 10.55% = 1055
    uint256 constant maxCommission = 10000;

    Counters.Counter internal _affiliateIdCounter;
    Counters.Counter internal _campaignIdCounter;

    // Tracks affiliates by ID
    mapping(uint256 => Affiliate) internal _affiliates;

    // Tracks campaigns by ID
    mapping(uint256 => Campaign) internal _campaigns;

    // Campaign ID => Affiliate ID => is registered
    mapping(uint256 => mapping(uint256 => bool)) private _affiliateRegs;

    // Campaign ID => Affiliate address => is registered
    mapping(uint256 => mapping(address => bool)) private _addressRegs;

    /***********************************|
    |          View Functions           |
    |__________________________________*/

    /**
     * @dev Gets campaign information by ID
     * @param _campaignId ID of the campaign to query
     * @return Campaign struct data
     */
    function getCampaign(uint256 _campaignId)
        public
        view
        returns (Campaign memory)
    {
        return _campaigns[_campaignId];
    }

    /**
     * @dev Gets campaign information by ID
     * @param _affiliateId ID of the affiliate to query
     * @return Campaign struct data
     */
    function getAffiliate(uint256 _affiliateId)
        public
        view
        returns (Affiliate memory)
    {
        return _affiliates[_affiliateId];
    }

    /**
     * @dev Returns whether an affiliate is registered with the campaign
     * @param _campaignId ID of the campaign to query
     * @param _affiliateId ID of the affiliate to query
     * @return True if affiliate has registered with campaign, False otherwise
     */
    function affiliateIsRegistered(uint256 _campaignId, uint256 _affiliateId)
        public
        view
        returns (bool)
    {
        return _affiliateIsRegistered(_campaignId, _affiliateId);
    }

    /**
     * @dev Gets affiliate's total rewards earned
     * @param _affiliateId ID of the affiliate to query
     * @return The affiliate's total rewards earned (in wei)
     */
    function totalRewardsOf(uint256 _affiliateId)
        public
        view
        returns (uint256)
    {
        return _caclulateAffiliateRewardTotal(_affiliateId);
    }

    /**
     * @dev Gets affiliate's unclaimed rewards
     * @param _affiliateId ID of the affiliate to query
     * @return The affiliate's unclaimed rewards (in wei)
     */
    function unclaimedRewardsOf(uint256 _affiliateId)
        public
        view
        returns (uint256)
    {
        return _caclulateAffiliateRewardEntitlement(_affiliateId);
    }

    /***********************************|
    |         Helper Functions          |
    |__________________________________*/

    /**
     * @dev Returns whether the campaign exists
     * @param _campaignId ID of the campaign to query
     * @return True if campaign owner is not zero address, False if so
     */
    function _campaignExists(uint256 _campaignId)
        internal
        view
        virtual
        returns (bool)
    {
        return _campaigns[_campaignId].owner != address(0);
    }

    /**
     * @dev Returns whether an affiliate exists
     * @param _affiliateId ID of the affiliate to query
     * @return True if affiliate account is not zero address, False if so
     */
    function _affiliateExists(uint256 _affiliateId)
        internal
        view
        virtual
        returns (bool)
    {
        return _affiliates[_affiliateId].account != address(0);
    }

    /**
     * @dev Returns whether the campaign is currently active
     * @param _campaignId ID of the campaign to query
     * @return True if campaign is active, False otherwise
     */
    function _campaignIsActive(uint256 _campaignId)
        internal
        view
        virtual
        returns (bool)
    {
        Campaign storage campaign = _campaigns[_campaignId];
        return
            campaign.startTime < block.timestamp &&
            campaign.endTime > block.timestamp;
    }

    /**
     * @dev Returns whether an affiliate is registered with the campaign
     * @param _campaignId ID of the campaign to query
     * @param _affiliateId ID of the affiliate to query
     * @return True if affiliate has registered with campaign, False otherwise
     */
    function _affiliateIsRegistered(uint256 _campaignId, uint256 _affiliateId)
        internal
        view
        virtual
        returns (bool)
    {
        return _affiliateRegs[_campaignId][_affiliateId];
    }

    /**
     * @dev Returns whether an affiliate is registered with the campaign
     * @param _campaignId ID of the campaign to query
     * @param _affiliateAddress Address of affiliate to query
     * @return True if address has registered as affiliate with campaign, False otherwise
     */
    function _addressIsRegistered(
        uint256 _campaignId,
        address _affiliateAddress
    ) internal view virtual returns (bool) {
        return _addressRegs[_campaignId][_affiliateAddress];
    }

    /**
     * @dev Calculate affiliate's total rewards for a specified campaign
     *
     * Calculation
     * (sales value * commission) / max commission
     *
     * @param _affiliateId ID of the affiliate to query
     * @return Total value of sales driven by the affiliate * affiliate's reward percentage
     */
    function _caclulateAffiliateRewardTotal(uint256 _affiliateId)
        internal
        view
        virtual
        returns (uint256)
    {
        Affiliate storage affiliate = _affiliates[_affiliateId];
        return (affiliate.salesValue * affiliate.commission) / maxCommission;
    }

    /**
     * @dev Calculate the reward currently entitled to an affiliate
     *
     * Calculation
     * ((sales value * commission) / max commission) - amount already withdrawn
     *
     * @param _affiliateId ID of the affiliate to query
     * @return Amount of reward currently entitled to the affiliate
     */
    function _caclulateAffiliateRewardEntitlement(uint256 _affiliateId)
        internal
        view
        virtual
        returns (uint256)
    {
        Affiliate storage affiliate = _affiliates[_affiliateId];
        return
            ((affiliate.salesValue * affiliate.commission) / maxCommission) -
            affiliate.amountWithdrawn;
    }

    /***********************************|
    |  Campaign Management Functions    |
    |__________________________________*/

    /**
     * @dev Create a new campaign from the given parameters.
     *
     * Requirements:
     * - `_owner` cannot be the zero address
     * - `_startTime` must be in the future
     * - `_endTime` must be greater than `_startTime`
     * - `_standardCommission` must be between 0 and 10000
     *
     * @param _owner Owner of the campaign
     * @param _startTime The time when the campaign becomes active
     * @param _endTime The time the campaign becomes inactive
     * @param _standardCommission Percentage of sales generated by affiliates that will be paid to the affiliate
     * @param _uri (Optional) URI containing the new campaign's information
     */
    function _createCampaign(
        address _owner,
        uint128 _startTime,
        uint128 _endTime,
        uint32 _standardCommission,
        string memory _uri
    ) internal virtual {
        require(
            _owner != address(0),
            "AffiliateMarketing: Owner cannot be the 0x0"
        );
        require(
            _startTime > block.timestamp - 1,
            "AffiliateMarketing: Start time cannot be in the past"
        );
        require(
            _startTime < _endTime,
            "AffiliateMarketing: Start time must be before end time"
        );

        require(_standardCommission > 0, "AffiliateMarketing: Reward is 0");
        require(
            _standardCommission < maxCommission,
            "AffiliateMarketing: Exceeded reward ceiling"
        );

        // Get the current campaign ID and increment
        uint256 campaignId = _campaignIdCounter.current();
        _campaignIdCounter.increment();

        Campaign storage newCampaign = _campaigns[campaignId];
        newCampaign.owner = _owner;
        newCampaign.uri = _uri;
        newCampaign.startTime = _startTime;
        newCampaign.endTime = _endTime;
        newCampaign.standardCommission = _standardCommission;

        emit CreateCampaign(
            campaignId,
            _owner,
            _startTime,
            _endTime,
            _standardCommission,
            _uri
        );
    }

    /**
     * @dev Update the URI of an existing campaign.
     *
     * Requirements:
     * - `_campaignId` must exist.
     * - `_owner` must match `_campaignId` owner.
     * - `_uri` cannot be blank.
     *
     * @param _campaignId ID of the campaign to update
     * @param _owner Owner of the campaign
     * @param _uri New URI for the campaign
     */
    function _updateCampaignMetadata(
        uint256 _campaignId,
        address _owner,
        string memory _uri
    ) internal virtual {
        require(
            _campaignExists(_campaignId),
            "AffiliateMarketing: Campaign does not exist"
        );
        require(
            bytes(_uri).length > 0,
            "AffiliateMarketing: URI cannot be empty"
        );

        Campaign storage campaign = _campaigns[_campaignId];
        require(
            campaign.owner == _owner,
            "AffiliateMarketing: Not campaign owner"
        );

        campaign.uri = _uri;

        emit UpdateCampaignMetadata(_campaignId, _uri);
    }

    /**
     * @dev Update the owner address of an existing campaign.
     *
     * Requirements:
     * - `_campaignId` must exist.
     * - `_owner` must match `_campaignId` owner.
     * - `_newOwner` cannot be the zero address.
     *
     * @param _campaignId ID of the campaign to update
     * @param _owner Owner of the campaign
     * @param _newOwner New owner address
     */
    function _updateCampaignOwner(
        uint256 _campaignId,
        address _owner,
        address _newOwner
    ) internal virtual {
        Campaign storage campaign = _campaigns[_campaignId];
        require(
            _campaignExists(_campaignId),
            "AffiliateMarketing: Campaign does not exist"
        );
        require(
            campaign.owner == _owner,
            "AffiliateMarketing: Not campaign owner"
        );
        require(
            _newOwner != address(0),
            "AffiliateMarketing: Owner cannot be 0x0"
        );
        campaign.owner = _newOwner;

        emit UpdateCampaignOwner(_campaignId, _newOwner);
    }

    /***********************************|
    |  Affiliate Management Functions   |
    |__________________________________*/

    /**
     * @dev Add affiliate to campaign.
     *
     * Requirements:
     * - `_campaignId` must exist.
     * - `_affiliate` cannot be the zero address.
     * - `_affiliate` cannot have been added to campaign.
     * - `_commission` must be between 0 and 10000
     *
     * @param _campaignId ID of the campaign to add affiliate to
     * @param _affiliate Address of new affiliate to add to campaign
     * @param _commission Percentage of sales that will be paid to the affiliate
     * @return ID of new campaign affiliate
     */
    function _addAffiliateToCampaign(
        uint256 _campaignId,
        address _affiliate,
        uint32 _commission
    ) internal virtual returns (uint256) {
        require(
            _affiliate != address(0),
            "AffiliateMarketing: Affiliate cannot be 0x0"
        );
        require(
            _campaignExists(_campaignId),
            "AffiliateMarketing: Campaign does not exist"
        );
        require(
            !_addressIsRegistered(_campaignId, _affiliate),
            "AffiliateMarketing: Already joined campaign"
        );

        require(_commission > 0, "AffiliateMarketing: Reward is 0");
        require(
            _commission < maxCommission + 1,
            "AffiliateMarketing: Exceeded reward ceiling"
        );

        // Get the current affiliate ID and increment
        uint256 affiliateId = _affiliateIdCounter.current();
        _affiliateIdCounter.increment();

        // Create new affiliate
        Affiliate storage affiliate = _affiliates[affiliateId];
        affiliate.account = _affiliate;
        affiliate.commission = _commission;

        // Register affiliate Id and address with campaign
        _affiliateRegs[_campaignId][affiliateId] = true;
        _addressRegs[_campaignId][_affiliate] = true;

        // Increment campaign's affiliate count
        unchecked {
            _campaigns[_campaignId].totalAffiliates += 1;
        }

        emit AddAffiliate(_campaignId, affiliateId, _affiliate, _commission);

        return affiliateId;
    }

    /**
     * @dev Credit affiliate with sale.
     *
     * Requirements:
     * - `_campaignId` must exist.
     * - `_affiliateId` must exist.
     * - `_affiliateId` must be registered with campaign.
     * - `_saleValue` must be greater than 0.
     *
     * @param _campaignId ID of the campaign to add affiliate to
     * @param _affiliateId ID of the affiliate that made the sale
     * @param _saleValue The value of the sale (in wei)
     */
    function _attributeSaleToAffiliate(
        uint256 _campaignId,
        uint256 _affiliateId,
        uint256 _saleValue
    ) internal virtual {
        require(
            _campaignIsActive(_campaignId),
            "AffiliateMarketing: Campaign not active"
        );
        require(
            _affiliateIsRegistered(_campaignId, _affiliateId),
            "AffiliateMarketing: Not registered with campaign"
        );
        require(_saleValue > 0, "AffiliateMarketing: Sale value is 0");

        Campaign storage campaign = _campaigns[_campaignId];
        Affiliate storage affiliate = _affiliates[_affiliateId];

        campaign.totalSalesValue += _saleValue;
        affiliate.salesValue += _saleValue;

        unchecked {
            campaign.totalSalesCount += 1;
            affiliate.salesCount += 1;
        }

        emit AttributeSale(_campaignId, _affiliateId, _saleValue);
    }

    /**
     * @dev Send ETH reward to affiliate.
     *
     * Requirements:
     * - `_affiliateId` must exist.
     * - `_affiliateId` must have > 0 unclaimed rewards.
     *
     * @param _affiliateId ID of the affiliate to query
     */
    function _sendRewardsToAffiliate(uint256 _affiliateId) internal virtual {
        require(
            _affiliateExists(_affiliateId),
            "AffiliateMarketing: Affiliate does not exist"
        );

        uint256 reward = _caclulateAffiliateRewardEntitlement(_affiliateId);
        require(reward > 0, "AffiliateMarketing: No reward");

        Affiliate storage affiliate = _affiliates[_affiliateId];

        // Send the reward to the affiliate
        affiliate.amountWithdrawn += reward;
        payable(affiliate.account).transfer(reward);

        emit SendRewards(_affiliateId, reward);
    }
}
